---
title: "A Tutorial for the poumm package"
author: Venelin Mitov
output:
  html_document:
  toc: true
pdf_document:
  toc: true
keep_tex: true
---
  
```{r setup, include=F}
library(knitr)
opts_chunk$set(size='tiny', out.extra='style="display:block; margin: auto;"', fig.align="center")

#library(rmarkdown)
# render('poumm-intro.Rmd', output_format='pdf_document', clean=T)

```

# Introduction
The **poumm** package provides an implementation of the Pylogenetic Mixed Model assuming an Ornstein-Uhlenbeck (OU)  or a Brownian Motion (BM) process of trait evolution along the branches. The package comes with an efficient likelihood calculation that scales to large phylogenies (currently tested with up to 10000 tips) and, if needed, can perform the likelihood calculation using the package **Rmpfr** for high precision floating point operations. 
Currently, the package depends on the package **ape** and the package **data.table**. The most important function of the package is "likVTReeOU" (see ?likVTreeOU), which performs likelihood calculation. Although the algorithm for likelihood calculation has been extensively tested and applied on various real as well as synthetic data, the package is still in a beta-version for the following reasons:

* The signature of the functions in the package may change;
* Some of the functions are not yet documented. 

Note: The high-precision likelihood calculation is usually needed in case of accumulating numerical errors due to extreme values of some of the parameters alpha, theta, sigma or sigmae or extreme (i.e. very long or very short) branch lengths in the phylogeny. As the Rmpfr package is currently not supported on all linux platforms, the poumm package doesn't explicitly depend on it, but you will need to install it manually and import it in case you specify usempfr=2 in the call to likVTreeOU. 


# Installing the package
```{r install, eval=F}
install.packages('poumm_0.1.tgz', type='binary', repos=NULL)
```

# A Hello World example

```{r example, cache=TRUE}
library(poumm)
library(pso)

# likelihood optimization using the particle swarm algorithm
# v : values at tips of the tree
# tree: the phylogen
# pso: control parameters for the call to psoptim
# ... : additional parameters for the call to likVTreeOU
psoLikVTreeOU <- function(v, tree, pso, ...) {
  minusll <- function(par, ...) {
    value <- -do.call(likVTreeOU, 
                      c(list(v, tree, 
                             alpha=par[1], theta=par[2], sigma=par[3], sigmae=par[4], 
                             log=T),
                                    list(...)))
    if(is.na(value) | is.nan(value) | is.infinite(value)) {
      1e20
    } else {
      value
    }
  }
  
  res <- do.call(psoptim, 
                 c(list(par=c(alpha=NA, theta=NA, sigma=NA, sigmae=NA), 
                        fn=minusll), pso))
  
  names(res$par) <- c('alpha', 'theta', 'sigma', 'sigmae')
  
  res
}

set.seed(1)
# Number of tips
N <- 1000
# true parameters
alpha <- 1
theta <- 4.5
sigma <- 2
sigmae <- 2

tree <- rtree(N)
tree$edge.length <- tree$edge.length/10

g <- generateTraitOU(tree, g0=6, alpha=alpha, theta=theta, sigma=sigma)
v <- rnorm(N, mean=0, sd=sigmae)+g[1:N]

#likelihood at the true value
lik <- likVTreeOU(v, tree, alpha, theta, sigma, sigmae, log=T, distgr='maxlik')

# setting the maxit parameter to a very small value (i.e. 2) while the 
# option 'hybrid' is on, would transform the pso algorithm into a gradient
# descent with a number of different original locations. 
fit <- psoLikVTreeOU(tree=tree, v=v, 
                     lik=list(distgr='maxlik', usempfr=1), 
                     pso=list(lower=c(0, 0, 0, 0), upper=c(10, 9, 10, 10), 
                              control=list(s=14, trace=1, trace.stats=T, REPORT=1, 
                                           hybrid='on', reltol=1e-3, maxit=2)))

# maximum likelihood fit:
print(fit$par)

# ml likelihood value versus value at the original true params
print(c(-fit$value, lik))

# spreadability at between infection interval 0:
h2 <- calcH2AtTime(fit$par[1], fit$par[3], fit$par[4], t=Inf, tm=0)

# plot the spreadability over delta t
t <- seq(0, 10, 0.1)
s2 <- calcH2AtTime(fit$par[1], fit$par[3], fit$par[4], t=Inf, tm=t)

# currently not executed
#matplot(x=t, y=s2, ylab=expression(s^2), xlab=expression(Delta*t), ylim=c(0,1), 
#        xlim=c(0,4), type='l')
```

# Further information and help
For further information, look in the package help-pages. If you cannot find the answer, please write me to venelin.mitov@bsse.ethz.ch. 
