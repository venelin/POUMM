---
title: "First Steps with the Phylogenetic Ornstein-Uhlenbeck Mixed Model"
author: "Venelin Mitov"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    fig_caption: yes
    toc: true
    toc_depth: 2
vignette: >
  %\VignetteIndexEntry{First Steps with the Phylogenetic Ornstein-Uhlenbeck Mixed Model}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: ../inst/REFERENCES.bib
---

```{r setup, include = FALSE}
# Make results reproducible
set.seed(1)
library(ggplot2)
library(data.table)
knitr::opts_chunk$set(cache = FALSE)
options(digits = 4)
```
Here, we introduce the R-package **POUMM** - an implementation of the Phylogenetic Ornstein-Uhlenbeck Mixed Model (POUMM) for univariate continuous traits [@Mitov:2016kd]. Whenever presented with data consisting of a rooted phylogenetic tree with observed trait-values at its tips, the **POUMM** package can be used to answer the following questions:

* Is the POUMM an appropriate model for the data?
* Assuming that the trait undergoes stabilizing selection, what are the long-term optimum value and the rate of convergence towards it?
* To what extent are the observed trait-values determined by heritable (i.e. genetic) versus non-heritable (i.e. environmental) factors?

<!--
TODO
* What is the profile of gradual loss of phenotypic resemblance between pair-tips as a function of their phylogenetic distance?
* What are the maximum-likelihood genotypic values of the root and tips of the tree?
-->

In the first section, we demonstrate how the package works. To that end, we run a toy-simulation of a trait according to the POUMM model. Then, we execute a maximum likelihood (ML) and a Bayesian (MCMC) POUMM fit to the simulated data. We show how to use plots and some diagnostics to assess the quality of the fit, i.e. the mixing and the convergence of the MCMC, as well as the consistency of the POUMM fit with the true POUMM parameters from the simulation.

In the second section we use variants of the toy-simulation to show how the  POUMM can be used to answer each of the questions stated above. 

But before we start, quickly install the needed packages:

```{r install, eval=FALSE}
install.packages('POUMM')
install.packages("TreeSim")
install.packages("data.table")
install.packages("ggplot2")
install.packages("lmtest")
```


# Simulating trait evolution under the POUMM 

## Parameters of the simulation
First, we specify the parameters of the POUMM simulation: 
```{r}
N <- 500
g0 <- 0           
alpha <- .5        
theta <- 2        
sigma <- 0.2     
sigmae <- 0.2 
```

We briefly explain the above parameters. The first four of them define an OU-process with initial state $g_0$, a selection strength parameter, $\alpha$, a long-term mean, $\theta$, and a stochastic time-unit standard deviation, $\sigma$. To get an intuition about the OU-parameters, one can consider random OU-trajectories using the function `POUMM::rTrajectoryOU`. On the figure below, notice that doubling $\alpha$ speeds up the convergence of the trajectory towards $\theta$ (magenta line) while doubling $\sigma$ results in bigger stochastic oscilations (blue line):

```{r, echo=FALSE, fig.height=4.6, fig.width=7, fig.cap="Dashed black and magenta lines denote the deterministic trend towards the long-term mean $\\theta$, fixing the stochastic parameter $\\sigma=0$."}
tStep <- 0.025
t <- seq(0, 6, by = tStep)

plot(t, POUMM::rTrajectoryOU(g0, tStep, alpha, theta, sigma, length(t)), type = 'l', main = "Random OU trajectories", ylab = "g", ylim = c(0, 4))
lines(t, POUMM::rTrajectoryOU(g0, tStep, alpha, theta, 0, length(t)), lty = 2)

lines(t, POUMM::rTrajectoryOU(g0, tStep, alpha*2, theta, sigma, length(t)), col = "magenta")
lines(t, POUMM::rTrajectoryOU(g0, tStep, alpha*2, theta, 0, length(t)), lty = 2, col = "magenta")

lines(t, POUMM::rTrajectoryOU(g0, tStep, alpha, theta, sigma*2, length(t)), col = "blue")

abline(h=theta, lty = 3, col = "darkgrey")

legend("topleft", 
       legend = c(expression(list(alpha == .5, theta == 2, sigma == 0.2)),
                  expression(list(alpha == .5, theta == 2, sigma == 0.4)),
                  expression(list(alpha == .5, theta == 2, sigma == 0)),
                  
                  expression(list(alpha == 1, theta == 2, sigma == 0.2)),
                  expression(list(alpha == 1, theta == 2, sigma == 0)),
                  
                  expression(theta == 2)),
       lty = c(1, 1, 2, 1, 2, 3), 
       col = c("black", "blue", "black", "magenta", "magenta", "darkgrey"))
```


The POUMM models the evolution of a continuous trait, $z$, along a phylogenetic tree, assuming that $z$ is the sum of a genetic (heritable) component, $g$, and an independent non-heritable (environmental) component, $e\sim N(0,\sigma_e^2)$. At every branching in the tree, the daughter lineages inherit the $g$-value of their parent, adding their own environmental component $e$. The POUMM assumes the genetic component, $g$, evolves along each lineage according to an OU-process with initial state the $g$ value inherited from the parent-lineage and global parameters $\alpha$, $\theta$ and $\sigma$. 

## Simulating the phylogeny
Once the POUMM parameters are specified, we use the **TreeSim** R-package [@R-TreeSim] to generate a random birth-death tree with `r N` tips:

```{r simulate-tree, results="hide"}
# Number of tips
tree <- TreeSim::sim.bdsky.stt(N, lambdasky = 1.6, deathsky = .6, 
                               timesky=c(0, Inf), sampprobsky = 1)[[1]]
```

## Simulating trait evolution on the phylogeny
Starting from the root value $g_0$, we simulate the genotypic values, $g$, and the environmental contributions, $e$, at all internal nodes down to the tips of the phylogeny:


```{r simulate-gez-OU}
# genotypic (heritable) values
g <- POUMM::rVNodesGivenTreePOUMM(tree, g0, alpha, theta, sigma)

# environmental contributions
e <- rnorm(length(g), 0, sigmae)

# phenotypic values
z <- g + e
```

## Visualizing the data
In most real situations, only the phenotypic value, at the tips, i.e. \code{z[1:N]} will be observable. One useful way to visualize the observed trait-values is to cluster the tips in the tree according to their root-tip distance, and to use box-whisker or violin plots to visualize the trait distribution in each group. This allows to visually assess the trend towards uni-modality and normality of the values - an important prerequisite for the POUMM. 

```{r violin-plots, fig.show = "hold", fig.height=4, fig.width=7, fig.cap="Distributions of the trait-values grouped according to their root-tip distances."}
# This is easily done using the nodeTimes utility function in combination with
# the cut-function from the base package.
data <- data.table(z = z[1:N], t = POUMM::nodeTimes(tree, tipsOnly = TRUE))
data <- data[, group := cut(t, breaks = 5, include.lowest = TRUE)]

ggplot(data = data, aes(x = t, y = z, group = group)) + 
  geom_violin(aes(col = group)) + geom_point(aes(col = group), size=.5)
```


## Fitting the POUMM
Once all simulated data is available, it is time proceed with a first POUMM fit. This is done easily by calling the POUMM function: 

```{r fitPOUMM-1, eval=TRUE, results="hide", message=FALSE, warning=FALSE}
fitPOUMM <- POUMM::POUMM(z[1:N], tree)
```

Be prepared that the call below can take up to 10 minutes to execute since it has to complete three MCMC chains: One chain sampling from the prior distribution and two MCMC chains starting from arbitrary points in the POUMM parameter space. This would allow to assess the quality of the POUMM fit later on. 

The above code runs for about 5 minutes on a MacBook Pro Retina (late 2013) with a 2.3 GHz Intel Core i7 processor. Using default settings, it performs a maximum likelihood (ML) and a Bayesian (MCMC) fit to the data. First the ML-fit is done. Then, three MCMC chains are run as follows: the first MCMC chain samples from the default prior distribution, i.e. assuming a constant POUMM likelihood; the second and the third chains perform adaptive Metropolis sampling from the posterior parameter distribution conditioned on the default prior and the data. By default each chain is run for $10^5$ iterations. This and other default POUMM settings are described in detail in the help-page for the function specifyPOUMM (see \code{?specifyPOUMM}). To speed-up the model-fit, it is possible to parallelize the MCMCs on a multi-core system (see the section "Parallelizing the MCMC sampling")

The strategy of executing three MCMC chains instead of one allows to assess: 

* the quality of the MCMC fit: a mismatch between the sampling distributions of the second and third chains suggests that at least one of the chains has not converged to a region of high posterior density (HPD). 
* the presence of signal for the POUMM parameters in the data: a close match between prior and posterior distributions suggests lack of signal in the data. 

We plot traces and posterior sample densities from the MCMC fit:

```{r, fig.height=4, fig.show="hold", fig.width=7, warning=FALSE, fig.cap="MCMC traces and posterior density plots from a POUMM MCMC-fit. Black dots on the x-axis indicate the ML-fit.", eval=TRUE}
plot(fitPOUMM, interactive = FALSE)
```

A mismatch of the posterior sample density plots from chains 2 and 3, in particular for the phylogenetic heritability, H2tMean, indicates that the chains have not converged. This can be confirmed quantitatively by the Gelman-Rubin statistic (column called G.R.) in the summary of the fit:

```{r, warning=FALSE, eval=TRUE}
summary(fitPOUMM)
```

The G.R. diagnostic is used to check whether two random samples originate from the same distribution. Values that are substantially different from 1.00 (in this case greater than 1.01) indicate significant difference between the two samples and possible need to increase the number of MCMC iterations. Therefore, we rerun the fit specifying that each chain should be run for $4 \times 10^5$ iterations:


```{r fitPOUMM-2, eval=TRUE, results="hide"}
fitPOUMM2 <- POUMM::POUMM(z[1:N], tree, spec=list(nSamplesMCMC = 4e5))  
```

Now, both the density plots and the G.R. values indicate nearly perfect convergence of the second and third chains. The agreement between the ML-estimates (black dots on the density plots) and the posterior density modes (approximate location of the peak in the density curves) shows that the prior does not inflict a bias on the MCMC sample. The mismatch between chain 1 and chains 2 and 3 suggests that the information about the POUMM parameters contained in the data disagrees with or significantly improves our prior knowledge about these parameters. This is the desired outcome of a Bayesian fit, in particular, in the case of a weak (non-informed) prior, such as the default one. 

```{r, fig.height=4, fig.show="hold", fig.width=7, warning=FALSE, eval=FALSE}
plot(fitPOUMM2, interactive = FALSE)
```

```{r, warning=FALSE, eval=TRUE}
summary(fitPOUMM2)
```

## Consistency of the fit with the "true" simulation parameters
The 95% high posterior density (HPD) intervals contain the true values for all five POUMM parameters ($\alpha$, $\theta$, $\sigma$, $\sigma_e$ and $g_0$). This is also true for the derived statistics. To check this, we calculate the true derived statistics from the true parameter values and check that these are well within the corresponding HPD intervals:

```{r}
tMean <- mean(POUMM::nodeTimes(tree, tipsOnly = TRUE))
tMax <- max(POUMM::nodeTimes(tree, tipsOnly = TRUE))

c(# phylogenetic heritability at mean root-tip distance: 
  H2tMean = POUMM::H2(alpha, sigma, sigmae, t = tMean),
  # phylogenetic heritability at long term equilibirium:
  H2tInf = POUMM::H2(alpha, sigma, sigmae, t = Inf),
  # empirical (time-independent) phylogenetic heritability, 
  H2e = POUMM::H2e(z[1:N], sigmae),
  # genotypic variance at mean root-tip distance: 
  sigmaG2tMean = POUMM::varOU(t = tMean, alpha, sigma),
  # genotypic variance at max root-tip distance: 
  sigmaG2tMean = POUMM::varOU(t = tMax, alpha, sigma),
  # genotypic variance at long-term equilibrium:
  sigmaG2tInf = POUMM::varOU(t = Inf, alpha, sigma)
  )
```

Finally, we compare the ratio of empirical genotypic to total phenotypic variance with the HPD-interval for the phylogenetic heritability. 

```{r, warning=FALSE, eval=TRUE}
c(H2empirical = var(g[1:N])/var(z[1:N]))
summary(fitPOUMM2)["H2tMean"==stat, unlist(HPD)]
```

## Parallelizing the MCMC
On multi-core systems, it is possible to speed-up the POUMM-fit by parallelizing the MCMC-chains. This can be done by creating a cluster using the parallel R-package:

```{r, eval=FALSE, echo=TRUE}
# set up a parallel cluster on the local computer for parallel MCMC:
cluster <- parallel::makeCluster(parallel::detectCores(logical = FALSE))
doParallel::registerDoParallel(cluster)

fitPOUMM <- POUMM::POUMM(z[1:N], tree, spec=list(parallelMCMC = TRUE))

# Don't forget to destroy the parallel cluster to avoid leaving zombie worker-processes.
parallel::stopCluster(cluster)
```

# Using the POUMM fit to answer biological questions

## Is the POUMM an appropriate model for the data?
The first step to answering that question is to visualize the data and check for obvious violations of the POUMM assumptions. The POUMM method expects that the trait-values at the tips are a sample from a multivariate normal distribution. With an ultrametric species tree, where all tips are equally distant from the root, this assumption translates in having all trait-values be realizations of identically distributed normal random variables. In the case of a non-ultrametric tree, it is far more useful to look at a sequence of box-whisker or violin plots of the trait-values, gouped by their root-tip distance. 

Once visualizing the data has confirmed its normality, we recommend comaparing the POUMM-fit with a fit from a NULL-model such as the phylogenetic mixed model (PMM) [@Housworth:2004gj]. Since the PMM is nested in the POUMM, i.e. in the limit $\alpha\to0$, the POUMM model is equivalent to a PMM model with the same initial genotypic value $g_0$ and unit-time variance $\sigma$, it is easy to fit a PMM model to the data by fixing the value of the parameter $\alpha$ to 0:

```{r}
specPMM <- POUMM::specifyPMM(z[1:N], tree)
fitPMM <- POUMM::POUMM(z[1:N], tree, spec = specPMM, doMCMC=FALSE)
```

Now a likelihood-ratio test between the maximum likelihood fits clearly shows that the POUMM fits significantly better to the data:

```{r, eval=FALSE}
lmtest::lrtest(fitPMM, fitPOUMM2)
```

As an exersise, we can generate data under the PMM model and see if a POUMM fit on that data remains significantly better than a PMM fit:

```{r}
gBM <- POUMM::rVNodesGivenTreePOUMM(tree, g0, alpha = 0, theta = 0, sigma = sigma)
zBM <- gBM + e

fitPMM_on_zBM <- POUMM::POUMM(zBM[1:N], tree, spec=specPMM, doMCMC = FALSE)
fitPOUMM_on_zBM <- POUMM::POUMM(zBM[1:N], tree, doMCMC = FALSE)

lmtest::lrtest(fitPMM_on_zBM, fitPOUMM_on_zBM)
```

## Assuming that the trait undergoes stabilizing selection, what are the long-term optimum value and the rate of convergence towards it?
To answer this question, consider the estimated values of the POUMM-parameters $\theta$ and
$\alpha$. Note that the parameter $\theta$ is relevant only if the value of the parameter $\alpha$ is 
significantly positive. One could accept that the ML-estimate for $\alpha$ is significantly positive
if a likelihood ratio test between a ML PMM and POUMM fits gives a p-value below a critical level 
(see the question above for an example). An inisignificant value of $\alpha$ reveals that the hypothesis
of neutral drift (Brownian motion) cannot be rejected.

## To what extent are the observed trait-values determined by heritable (i.e. genetic) versus non-heritable (i.e. environmental) factors?
In other words, what is the proportion of observable phenotypic variance attributed to the phylogeny? To answer this question one needs to estimate the phylogenetic heritability of the trait. Assuming that the tree represents the genetic relationship between individuals in a population, $H_\bar{t}^2$ provides an estimate for the broad-sense heritability $H^2$ of the trait in the population. The POUMM package reports the following three types of phylogenetic heritability (see table \ref{tab:table1} for simplified expressions):

* Expectation at the mean root-tip distance : $H_{\bar{t}}^2:=\left[\sigma^2\, \frac{\left(1-e^{-2\alpha \bar{t}}\right)}{2\alpha}\right]/\left[\sigma^2\, \frac{\left(1-e^{-2\alpha \bar{t}}\right)}{2\alpha}+\sigma_e^2\right]$;
* Expectation at equilibrium of the OU-process: $H_{\infty}^2:=\lim_{\bar{t}\to\infty}H_{\bar{t}}^2$;
* Empirical (time-independent) version of the heritability based on the sample phenotypic variance $s^2(\textbf{z})$ : $H_e^2:=1-\sigma_e^2/s^2(\textbf{z})$.

<!--
TODO
## What is the profile of gradual loss of phenotypic resemblance between pair-tips as a function of their phylogenetic distance?


## What are the maximum-likelihood genotypic values of the root and tips of the tree?
-->


# Packages used
```{r create-references, echo=FALSE, include=FALSE, eval=TRUE}
likCalculation <- c("Rcpp", "RcppArmadillo", "Rmpfr")
mcmcSampling <- c("adaptMCMC")
mcmcDiagnosis <- c("coda")
otherPackages <- c("parallel", "foreach", "data.table", "Matrix", "gsl")
treeProcessing <- c("ape")
reporting <- c("data.table", "ggplot2", "lmtest")
testing <- c("testthat", "mvtnorm", "TreeSim")
 
packagesUsed <- c(likCalculation, mcmcDiagnosis, otherPackages, treeProcessing, reporting, testing)

printPackages <- function(packs) {
  res <- ""
  for(i in 1:length(packs)) {
    res <- paste0(res, paste0(packs[i], ' v', packageVersion(packs[i]), ' [@R-', packs[i], ']'))
    if(i < length(packs)) {
      res <- paste0(res, ', ')
    }
  }
  res
}

# Write bib information (this line is executed manually and the bib-file is edited manually after that)
# knitr::write_bib(packagesUsed, file = "./REFERENCES.bib")
```


Apart from base R functionality, the POUMM package uses a number of 3rd party R-packages:

* For likelihood calculation: `r printPackages(likCalculation)`;
* For mcmcSampling: `r printPackages(mcmcSampling)`;
* For MCMC convergence diagnostics, calculation of MCMC effective sizes and HPD-intervals: `r printPackages(mcmcDiagnosis)`;
* For other purposes (parameter transformations and summary statistics): `r printPackages(otherPackages)`);
* For tree processing: `r printPackages(treeProcessing)`;
* For reporting: `r printPackages(reporting)`;
* For testing: `r printPackages(testing)`.

# References